require "../spec_helper"

private macro parse_token(kw, type)
  it "parses '#{{{ kw }}}' as #{{{ type }}}" do
    document = Larimar::Parser::Document.new({{ kw }})
    Larimar::Parser::Lexer.lex_full(document)

    document.lex_errors.should be_empty
    document.tokens.should eq([
      Larimar::Parser::Token.new({{ type }}, 0, {{ kw.size }}, false),
      Larimar::Parser::Token.new(:EOF, 0, 0, false)
    ])
  end
end

private macro parse_tokens(kw, tokens)
  it "parses '#{{{ kw }}}' as #{{{ tokens }}.map(&.kind).join(", ")}" do
    document = Larimar::Parser::Document.new({{ kw }})
    Larimar::Parser::Lexer.lex_full(document)

    document.lex_errors.should be_empty
    document.tokens.should eq({{ tokens }} + [
      Larimar::Parser::Token.new(:EOF, 0, 0, false)
    ])
  end
end

describe Larimar::Parser::Lexer do
  parse_token("abstract", :KW_ABSTRACT)
  parse_token("abstract_word", :IDENT)
  parse_token("alias", :KW_ALIAS)
  parse_token("alias_word", :IDENT)
  parse_token("alignof", :KW_ALIGNOF)
  parse_token("alignof_word", :IDENT)
  parse_token("asm", :KW_ASM)
  parse_token("asm_word", :IDENT)
  parse_token("as?", :KW_AS_QUESTION)
  parse_tokens("as?word", [
    Larimar::Parser::Token.new(:KW_AS_QUESTION, 0, 3, false),
    Larimar::Parser::Token.new(:IDENT, 0, 4, false),
  ])
  parse_token("as", :KW_AS)
  parse_token("as_word", :IDENT)
  parse_token("annotation", :KW_ANNOTATION)
  parse_token("annotation_word", :IDENT)
  parse_token("begin", :KW_BEGIN)
  parse_token("begin_word", :IDENT)
  parse_token("break", :KW_BREAK)
  parse_token("break_word", :IDENT)
  parse_token("case", :KW_CASE)
  parse_token("case_word", :IDENT)
  parse_token("class", :KW_CLASS)
  parse_token("class_word", :IDENT)
  parse_token("def", :KW_DEF)
  parse_token("def_word", :IDENT)
  parse_token("do", :KW_DO)
  parse_token("do_word", :IDENT)
  parse_token("else", :KW_ELSE)
  parse_token("else_word", :IDENT)
  parse_token("elsif", :KW_ELSIF)
  parse_token("elsif_word", :IDENT)
  parse_token("end", :KW_END)
  parse_token("end_word", :IDENT)
  parse_token("false", :KW_FALSE)
  parse_token("false_word", :IDENT)
  parse_token("for", :KW_FOR)
  parse_token("for_word", :IDENT)
  parse_token("forall", :KW_FORALL)
  parse_token("forall_word", :IDENT)
  parse_token("fun", :KW_FUN)
  parse_token("fun_word", :IDENT)
  parse_token("if", :KW_IF)
  parse_token("if_word", :IDENT)
  parse_token("include", :KW_INCLUDE)
  parse_token("include_word", :IDENT)
  parse_token("instance_sizeof", :KW_INSTANCE_SIZEOF)
  parse_token("instance_sizeof_word", :IDENT)
  parse_token("instance_alignof", :KW_INSTANCE_ALIGNOF)
  parse_token("instance_alignof_word", :IDENT)
  parse_token("is_a?", :KW_IS_A_QUESTION)
  parse_tokens("is_a?word", [
    Larimar::Parser::Token.new(:KW_IS_A_QUESTION, 0, 5, false),
    Larimar::Parser::Token.new(:IDENT, 0, 4, false),
  ])
  parse_token("is_a_word", :IDENT)
  parse_token("lib", :KW_LIB)
  parse_token("lib_word", :IDENT)
  parse_token("macro", :KW_MACRO)
  parse_token("macro_word", :IDENT)
  parse_token("module", :KW_MODULE)
  parse_token("module_word", :IDENT)
  parse_token("next", :KW_NEXT)
  parse_token("next_word", :IDENT)
  parse_token("nil?", :KW_NIL_QUESTION)
  parse_tokens("nil?word", [
    Larimar::Parser::Token.new(:KW_NIL_QUESTION, 0, 4, false),
    Larimar::Parser::Token.new(:IDENT, 0, 4, false),
  ])
  parse_token("nil", :KW_NIL)
  parse_token("nil_word", :IDENT)
  parse_token("offsetof", :KW_OFFSETOF)
  parse_token("offsetof_word", :IDENT)
  parse_token("of", :KW_OF)
  parse_token("of_word", :IDENT)
  parse_token("out", :KW_OUT)
  parse_token("out_word", :IDENT)
  parse_token("pointerof", :KW_POINTEROF)
  parse_token("pointerof_word", :IDENT)
  parse_token("private", :KW_PRIVATE)
  parse_token("private_word", :IDENT)
  parse_token("protected", :KW_PROTECTED)
  parse_token("protected_word", :IDENT)
  parse_token("rescue", :KW_RESCUE)
  parse_token("rescue_word", :IDENT)
  parse_token("responds_to?", :KW_RESPONDS_TO_QUESTION)
  parse_tokens("responds_to?word", [
    Larimar::Parser::Token.new(:KW_RESPONDS_TO_QUESTION, 0, 12, false),
    Larimar::Parser::Token.new(:IDENT, 0, 4, false),
  ])
  parse_token("return", :KW_RETURN)
  parse_token("return_word", :IDENT)
  parse_token("require", :KW_REQUIRE)
  parse_token("require_word", :IDENT)
  parse_token("select", :KW_SELECT)
  parse_token("select_word", :IDENT)
  parse_token("self", :KW_SELF)
  parse_token("self_word", :IDENT)
  parse_token("sizeof", :KW_SIZEOF)
  parse_token("sizeof_word", :IDENT)
  parse_token("struct", :KW_STRUCT)
  parse_token("struct_word", :IDENT)
  parse_token("super", :KW_SUPER)
  parse_token("super_word", :IDENT)
  parse_token("then", :KW_THEN)
  parse_token("then_word", :IDENT)
  parse_token("true", :KW_TRUE)
  parse_token("true_word", :IDENT)
  parse_token("typeof", :KW_TYPEOF)
  parse_token("typeof_word", :IDENT)
  parse_token("union", :KW_UNION)
  parse_token("union_word", :IDENT)
  parse_token("uninitialized", :KW_UNINITIALIZED)
  parse_token("uninitialized_word", :IDENT)
  parse_token("unless", :KW_UNLESS)
  parse_token("unless_word", :IDENT)
  parse_token("until", :KW_UNTIL)
  parse_token("until_word", :IDENT)
  parse_token("verbatim", :KW_VERBATIM)
  parse_token("verbatim_word", :IDENT)
  parse_token("when", :KW_WHEN)
  parse_token("when_word", :IDENT)
  parse_token("while", :KW_WHILE)
  parse_token("while_word", :IDENT)
  parse_token("with", :KW_WITH)
  parse_token("with_word", :IDENT)
  parse_token("yield", :KW_YIELD)
  parse_token("yield_word", :IDENT)
  parse_token("__DIR__", :MAGIC_DIR)
  parse_token("__DIR__WORD", :IDENT)
  parse_token("__END_LINE__", :MAGIC_END_LINE)
  parse_token("__END_LINE__WORD", :IDENT)
  parse_token("__FILE__", :MAGIC_FILE)
  parse_token("__FILE__WORD", :IDENT)
  parse_token("__LINE__", :MAGIC_LINE)
  parse_token("__LINE__WORD", :IDENT)
  parse_token("__", :IDENT)
  parse_token("_", :UNDERSCORE)
end
